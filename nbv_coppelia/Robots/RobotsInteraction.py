from math import pi, sin, cos
from pyrep.robots.arms.youBot import youBot
from pyrep.robots.mobiles.youbot import YouBot
import pyrep.objects as PyRepObj
from dqrobotics import *
from dqrobotics.robot_modeling import DQ_SerialManipulatorDH, DQ_HolonomicBase, DQ_SerialWholeBody
from dqrobotics.interfaces.vrep.robots import *
import math
import numpy as np
from Robots.Communication import BaseCommunication
from typing import List


class YouBotModel(BaseCommunication):

    """
    This class is for creating youbot`s kinematic model using dqrobotics library 
    and communicating with the coppeliasim using pyrep library. The pyrep library is only used for communication purposes 
    e.g., sending base wheel and arm joint velocities
    """

    def __init__(self, is_velocity_control=False):

        super(YouBotModel, self).__init__()
        self.robot_radius = 0.35

        # Ref dummy frane attached to the robot base(x: forward, z:up)
        self.youbot_base_ref = PyRepObj.Object.get_object("dqRef")
        self.youbot_base_pyrep = YouBot()  # Pyrep youbot base model
        self.youbot_arm_pyrep = youBot()   # Pyrep youbot arm model
        self.is_velocity_control = is_velocity_control

        is_camera_active = True  # If true, add camera transformation to kinematic chain

        # DH Parameters of the Youbot arm
        pi2 = math.pi / 2
        self.dh_mat = np.array([[0,      pi2,       0,      pi2,    0],
                               [0.147,    0,       0,        0,    0.218],
                               [0.033,    0.155,   0.135,    0,    0],
                               [pi2,      0,       0,      pi2,    0],
                               [0, 0, 0, 0, 0]])

        # Create the kinematic model of mobile maniopulator
        arm = DQ_SerialManipulatorDH(self.dh_mat)
        base = DQ_HolonomicBase()
        x_bm = 1 + E_ * 0.5 * (0.156 * i_ + 0.085 * k_)
        base.set_frame_displacement(x_bm)
        kin = DQ_SerialWholeBody(base)
        if is_camera_active:
            rot = math.cos(-pi2/2)+math.sin(-pi2/2)*k_
            arm.set_effector(rot)
        kin.add(arm)
        self.youbot_kinematic = kin

        # YouBot base in coppeliaSim does not have the same pose as the dqrobotics)(x does not face forward and there is an offset).
        # Thus, before sending base position generated by dqrobotics, a tranformation should be applied.
        # Note: Setting poseof the base works only if you disable dynamics otherwise velocity must be sent.
        self.adjust_pose = (cos(pi / 4) + k_ * sin(pi / 4)) * \
            (1 + 0.5 * E_ * -0.1 * k_)

    def get_q_from_sim(self):
        if self.is_velocity_control:
            return self.get_q_from_sim_vel()
        else:
            return self.get_q_from_sim_pos()

    def get_q_from_sim_vel(self) -> List:
        """ Get the pose of the holonomic base [x,y,phi] using dq reference frame(self.youbot_base_ref )
        and joint positions of the arm.

        :return: base pose and arm joint position as list [x,y,phi,th0,th1,th2,th3,th4]
        """

        base_position = self.youbot_base_ref.get_position()
        base_phi = self.youbot_base_ref.get_orientation()[-1]
        # Get the joint values of arm directly
        joint_angles = self.youbot_arm_pyrep.get_joint_positions()
        return [base_position[0], base_position[1], base_phi, *joint_angles]

    def get_q_from_sim_pos(self) -> List:
        # Get the adjusted pose of the holonomic base
        # [x,y,phi])
        base_x = self.get_object_pose(
            self.youbot_base_pyrep) * self.adjust_pose
        base_t = vec4(translation(base_x))
        print(base_t)
        base_phi = rotation_angle(rotation(base_x))
        # Get the joint values of arm directly
        jointAngles = self.youbot_arm_pyrep.get_joint_positions()
        return [base_t[1], base_t[2], base_phi, *jointAngles]

    # Use this function only the robot is controlled in position mode and dynamics of the robot is disabled.

    def send_q_to_sim(self, q: List) -> None:
        """ Set the adjusted pose of the holonomic base and position of arm joints
        :param q: desired base pose and arm joint position as list [x,y,phi,th0,th1,th2,th3,th4]
        """

        x, y, phi = q[0], q[1], q[2]
        r = cos(phi / 2.0) + k_ * sin(phi / 2.0)
        p = x * i_ + y * j_
        pose = (1 + E_ * 0.5 * p) * r
        pose = pose * conj(self.adjust_pose)
        self.set_object_pose(self.youbot_base_pyrep, pose)
        self.youbot_arm_pyrep.set_joint_positions(list(q[3:]))

    @property
    def Kinematics(self):
        return self.youbot_kinematic

    @property
    def BaseKinematics(self):
        return self.youbot_kinematic.get_chain_as_holonomic_base(0)

    @property
    def ArmKinematics(self):
        return self.youbot_kinematic.get_chain_as_serial_manipulator_dh(1)

    def send_velocities(self, velocities: List) -> None:
        """ Set wheel velocities of the holonomic base and joint velocities of the arm.
        :param velocities: desired base and arm velocities as list [x_dot,y_dot,phi_dot,th0_dot,
                                                                    th1_dot,th2_dot,th3_dot,th4_dot]
        """

        forwBackVel = velocities[0]
        leftRightVel = -velocities[1]
        rotVel = -velocities[2]
        lx = 0.5*3.5707e-01  # Distance from wheel center to x axis from body fram in m
        ly = 0.5*5.7010e-01  # Distance from wheel center to y axis from body frame in m
        r = 0.5*9.9968e-02  # Radius of the wheel in m
        Wheel1 = (-forwBackVel-leftRightVel-(lx+ly)*rotVel)/r
        Wheel2 = (-forwBackVel+leftRightVel-(lx+ly)*rotVel)/r
        Wheel3 = (-forwBackVel-leftRightVel+(lx+ly)*rotVel)/r
        Wheel4 = (-forwBackVel+leftRightVel+(lx+ly)*rotVel)/r
        self.youbot_base_pyrep.set_joint_target_velocities([Wheel1,
                                                            Wheel2,
                                                            Wheel3,
                                                            Wheel4])
        arm_vel = velocities[3:]
        self.youbot_arm_pyrep.set_joint_target_velocities(arm_vel)
